####################################################################################################
# Procedure - CreateColumnSection: Defines a procedure which generates a rectangular reinforced concrete section
#  with two outer layers of longitudinal bars and multiple intermediate layers of longitudinal bars, evenly 
# spaced between the outer layers.  Note that the "cover" is both used for both the clear cover and 
# the side cover.  For each intermediate layer, two bars are placed at each of the layers.
#
# Original file written by: Paul Cordova
# Date: 09/2001
#
# Altered by: Curt Haselton 
# Date: 03/2004
# 
#                       y
#                       |
#                       |
#                       |    
#             ---------------------
#             |			    |
#             |  o o o o o o o o  |
#             |   		    |			Ex. numBotBars = 8
#             |  o             o  |			    numTopBars = 8
#  z ---------|                   |  h		    numInterLayers = 3 
#	        |  o 		 o  |
#		  |			    |	
#		  |  o      	 o  |	
#             |      	          |
#             |  o o o o o o o o  |
#             |                   |
#             ---------------------
#                       b
#
# Formal arguments
#    id - tag for the section that is generated by this procedure
#    h - overall height of the section (see above)
#    b - overall width of the section (see above)
#    cover - thickness of the cover patches (from edge to center of bar)
#    coreID - material tag for the core patch
#    coverID - material tag for the cover patches
#    steelID - material tag for the reinforcing steel
#    longBarArea - area of each longitudinal reinforcing bar (same for top/bot bars) 
#    numBotBars - number of tension (bottom) bars
#    numTopBars - number of compression (top) bars
#    interBarArea - area of each intermediate reinforcing bar 
#    numInterLayers - number of intermediate layers of bars (2 bars per intermediate layer)
#    nfCoreY - number of fibers in the core patch in the y direction
#    nfCoreZ - number of fibers in the core patch in the z direction
#    nfCoverY - number of fibers in the cover patches with long sides in the y direction
#    nfCoverZ - number of fibers in the cover patches with long sides in the z direction
#
# Notes
#    The thickness of cover concrete is constant on all sides of the core.
#    The number of bars is the same on any given side of the section.
#    The reinforcing bars are all the same size.
#    The number of fibers in the short direction of the cover patches is set to 1.
# 
proc CreateColumnSection {id h b cover coreID coverID steelID db longBarArea numBotBars numTopBars interBarArea numInterLayers ShearTag fc fyt rou nfCoreY nfCoreZ nfCoverY nfCoverZ} {

   # Do outputs for testing
#   puts "id is $id"
#   puts "h is $h"
#   puts "cover is $cover"
#   puts "coreid is $coreID"
#   puts "coverID is $coverID"
#   puts "steelID is $steelID"
#   puts "longBarArea is $longBarArea"
#   puts "numBotBars is $numBotBars"
#   puts "numTopBars is $numTopBars"
#   puts "interBarArea is $interBarArea"
#   puts "numInterLayers is $numInterLayers"
#   puts "nfCoreY is $nfCoreY"
#   puts "nfCoreZ is $nfCoreZ"
#   puts "nfCoverY is $nfCoverY"
#   puts "nfCoverZ is $nfCoverZ"

   # Set number of intermediate bars per layer
   set numInterBarsPerLayer 2

   # The distance from the section z-axis to the edge of the cover concrete
   # in the positive y direction
   set coverY [expr $h/2.0]

   # The distance from the section y-axis to the edge of the cover concrete
   # in the positive z direction
   set coverZ [expr $b/2.0]

   # The negative values of the two above
   set ncoverY [expr -$coverY]
   set ncoverZ [expr -$coverZ]

   # Determine the corresponding values from the respective axes to the
   # edge of the core concrete
   set coreY [expr $coverY-$cover]
   set coreZ [expr $coverZ-$cover]
   set ncoreY [expr -$coreY]
   set ncoreZ [expr -$coreZ]

   # Define the fiber section
	set id_temp [expr $id+1000];
   section fiberSec $id_temp {

	# Define the core patch - CHECKED and good (9-13-04)
	patch quadr $coreID $nfCoreY $nfCoreZ $ncoreY $coreZ $ncoreY $ncoreZ $coreY $ncoreZ $coreY $coreZ
      
	# Define the four cover patches  - I changed this on 9-13-04 - The top and bottom covers were discretized wrong.
	# Side cover
	patch quadr $coverID $nfCoreY $nfCoverZ $ncoverY $coverZ $ncoreY $coreZ $coreY $coreZ $coverY $coverZ
	patch quadr $coverID $nfCoreY $nfCoverZ $ncoreY $ncoreZ $ncoverY $ncoverZ $coverY $ncoverZ $coreY $ncoreZ
	# Top and bottom cover
	patch quadr $coverID $nfCoverY $nfCoreZ $ncoverY $coverZ $ncoverY $ncoverZ $ncoreY $ncoreZ $ncoreY $coreZ
	patch quadr $coverID $nfCoverY $nfCoreZ $coreY $coreZ $coreY $ncoreZ $coverY $ncoverZ $coverY $coverZ

	# Define the steel layers
	# Top layer
	layer straight $steelID $numTopBars $longBarArea [expr $coreY-0.5*$db] [expr $ncoreZ+0.5*$db] [expr $coreY-0.5*$db] [expr $coreZ-0.5*$db]; 	
	# Bottom layer
	layer straight $steelID $numBotBars $longBarArea [expr $ncoreY+0.5*$db] [expr $ncoreZ+0.5*$db] [expr $ncoreY+0.5*$db] [expr $coreZ-0.5*$db]; 

	# Do intermediate layers if they exist
#	puts "Check: Number of intermeddiate layers is $numInterLayers"
   	if {$numInterLayers == 0} {
		# Don't make any intermediate layers of bars
   	} else {
		# Compute spacing of intermediate layers (equally spaced)
		set interSpacing [expr (($h - 2*$cover - $db)/[expr $numInterLayers + 1])]
		#puts "Inter spacing is $interSpacing"
		
		# Make intermediate layers
		set layerDepth [expr ($coreY - 0.5*$db - $interSpacing)]
		for {set layerNum 1} {$layerNum < [expr $numInterLayers + 1]} {incr layerNum 1} {
			layer straight $steelID $numInterBarsPerLayer $interBarArea $layerDepth $coreZ $layerDepth $ncoreZ; 
			#puts "Intermediate layer placed at $layerDepth"
			set layerDepth [expr $layerDepth - $interSpacing]
		}
   	}	
   }

	puts "Start working on the aggregated shear section."
	# Define the shear material
	set Ec [expr 57.0*sqrt(-$fc*1000.0)];
	set Gc [expr $Ec/2.0/(1+0.2)];
	set alpha_c 3.0;	# flexure dominated behavior
	set vn [expr $alpha_c*sqrt(-$fc*1000.0)/1000.0+$rou*$fyt];
	if {$vn > [expr 8*sqrt(-$fc*1000.0)/1000.0]} {
		set vn [expr 8*sqrt(-$fc*1000.0)/1000.0];
	}
	set s1p [expr 0.002*sqrt(-$fc*1000.0)*$h*$b];
	set e1p [expr $s1p/$Gc/($h*$b)];
	set s2p [expr 0.6*$vn*$h*$b];
	set e2p [expr $e1p+($s2p-$s1p)/0.4/$Gc/($h*$b)];
	set s3p [expr $vn*$h*$b];
	set e3p [expr $e2p+0.4*$vn/0.1/$Gc];
	set s1n [expr -$s1p];
	set e1n [expr -$e1p];
	set s2n [expr -$s2p];
	set e2n [expr -$e1p-($s2p-$s1p)/0.4/$Gc/($h*$b)];
	set s3n [expr -$s3p];
	set e3n [expr -$e3p];
	set pinchX 0.9;
	set pinchY 0.1;
	set damage1 0;
	set damage2 0;
	set beta 0.0;
	if {$ShearTag == "Linear"} {
		uniaxialMaterial Elastic $id_temp [expr 0.1*$s1p/$e1p];
		puts "K_shear [expr 0.1*$s1p/$e1p]";
	} else {
	#		puts "$id_temp $s1p $e1p $s2p $e2p $s3p $e3p $s1n $e1n $s2n $e2n $s3n $e3n $pinchX $pinchY $damage1 $damage2 $beta"
		uniaxialMaterial Hysteretic $id_temp $s1p $e1p $s2p $e2p $s3p $e3p $s1n $e1n $s2n $e2n $s3n $e3n $pinchX $pinchY $damage1 $damage2 $beta;
	}	
	   # Aggregate the shear material to the flexure section
	section Aggregator $id $id_temp Vy -section $id_temp;

	puts "Finish working on the shear section."

}
####################################################################################################
# Procedure - CreateBeamWithSlabSection: Defines a procedure which generates a rectangular reinforced concrete section
#  with two outer layers of longitudinal bars and multiple intermediate layers of longitudinal bars, evenly 
# spaced between the outer layers.  Note that the "cover" is both used for both the clear cover and 
# the side cover.  For each intermediate layer, two bars are placed at each of the layers.
# The slab is added to the -z side of the section, but it really doesn't matter b/c of the PSRP 
# assumption.  Slab steel is placed at the top and the bottom of the slab section, a distance
# "slab cover" from the top and bototm of the section.  A slab bar is only placed if the slab width
# is >= the slab bar spacing.
#
# If slab width or slab thinkness is < 0, then no slab is created.  
# If slabBarSpacing is > slabWidth, then no slab stell is defined. 
#
# Original file written by: Paul Cordova
# Date: 09/2001
#
# Altered by: Curt Haselton 
# Date: 03/2004
# 
#                       y
#                       |
#                       |	    |<-----------slabWidth----------->|
#                       |    
#             -------------------------------------------------------
#             |			    |o             o             o   
#             |  o o o o o o o o  |
#             |   		    |o_____________o_____________o_____	
#             |  o             o  |			    
#  z ---------|                   |  h		    
#	        |  o 		 o  |				
#		  |			    |			Ex. 	numBotBars = 8
#		  |  o      	 o  |				numTopBars = 8
#             |      	          |				numInterLayers = 3 
#             |  o o o o o o o o  |
#             |                   |
#             ---------------------
#                       b
#
# Formal arguments
#    id - tag for the section that is generated by this procedure
#    h - overall height of the section (see above)
#    b - overall width of the section (see above)
#    cover - thickness of the cover patches (from edge to center of bar) for the beam
#    coreID - material tag for the core patch
#    coverID - material tag for the cover patches
#    slabID - material tag for the slab patches
#    steelID - material tag for the reinforcing steel
#    longBarArea - area of each longitudinal reinforcing bar (same for top/bot bars) 
#    numBotBars - number of tension (bottom) bars
#    numTopBars - number of compression (top) bars
#    interBarArea - area of each intermediate reinforcing bar 
#    numInterLayers - number of intermediate layers of bars (2 bars per intermediate layer)
#    slabWidth - slab width in addition to the beam width
#    slabThick - slab thickness
#    slabBarArea -  area of each slab steel reinforcing bar (same for top/bot bars) 
#    slabBarSpacing - spacing between sets of slab bars - BE SURE THIS IS NOT ZERO BECAUSE OF DIVISION!
#    slabBarCover - cover to center of slab bars - used for both top and bottom bar layers
#    nfCoreY - number of fibers in the core patch in the y direction
#    nfCoreZ - number of fibers in the core patch in the z direction
#    nfCoverY - number of fibers in the cover patches with long sides in the y direction
#    nfCoverZ - number of fibers in the cover patches with long sides in the z direction
#    nfSlabY - number of fibers in the slab with long sides in the y direction
#    nfSlabZ - number of fibers in the slab with long sides in the z direction
#
# Notes
#    The thickness of cover concrete is constant on all sides of the core.
#    The number of bars is the same on any given side of the section.
#    The reinforcing bars are all the same size.
#    The number of fibers in the short direction of the cover patches is set to 1.
# 
proc CreateBeamWithSlabSection {id h b cover coreID coverID slabID steelID longBarArea numBotBars numTopBars interBarArea numInterLayers slabWidth slabThick slabBarArea slabBarSpacing slabBarCover nfCoreY nfCoreZ nfCoverY nfCoverZ nfSlabY nfSlabZ} {

   # Do outputs for testing
#   puts "id is $id"
#   puts "h is $h"
#   puts "cover is $cover"
#   puts "coreid is $coreID"
#   puts "coverID is $coverID"
#   puts "steelID is $steelID"
#   puts "longBarArea is $longBarArea"
#   puts "numBotBars is $numBotBars"
#   puts "numTopBars is $numTopBars"
#   puts "interBarArea is $interBarArea"
#   puts "numInterLayers is $numInterLayers"
#   puts "nfCoreY is $nfCoreY"
#   puts "nfCoreZ is $nfCoreZ"
#   puts "nfCoverY is $nfCoverY"
#   puts "nfCoverZ is $nfCoverZ"

   # Set number of intermediate bars per layer
   set numInterBarsPerLayer 2

   # The distance from the section z-axis to the edge of the cover concrete
   # in the positive y direction
   set coverY [expr $h/2.0]

   # The distance from the section y-axis to the edge of the cover concrete
   # in the positive z direction
   set coverZ [expr $b/2.0]

   # The negative values of the two above
   set ncoverY [expr -$coverY]
   set ncoverZ [expr -$coverZ]

   # Determine the corresponding values from the respective axes to the
   # edge of the core concrete
   set coreY [expr $coverY-$cover]
   set coreZ [expr $coverZ-$cover]
   set ncoreY [expr -$coreY]
   set ncoreZ [expr -$coreZ]

   # Define the fiber section
   section fiberSec $id {

	# Define the core patch - OK - checked on 9-13-04
	patch quadr $coreID $nfCoreZ $nfCoreY $ncoreY $coreZ $ncoreY $ncoreZ $coreY $ncoreZ $coreY $coreZ
      
	# Define the four cover patches  - I changed this on 9-13-04 - The top and bottom covers were discretized wrong.
	# Side cover
	patch quadr $coverID $nfCoverZ $nfCoreY $ncoverY $coverZ $ncoreY $coreZ $coreY $coreZ $coverY $coverZ
	patch quadr $coverID $nfCoverZ $nfCoreY $ncoreY $ncoreZ $ncoverY $ncoverZ $coverY $ncoverZ $coreY $ncoreZ
	# Top and bottom cover
	patch quadr $coverID $nfCoverZ $nfCoverY $ncoverY $coverZ $ncoverY $ncoverZ $ncoreY $ncoreZ $ncoreY $coreZ
	patch quadr $coverID $nfCoverZ $nfCoverY $coreY $coreZ $coreY $ncoreZ $coverY $ncoverZ $coverY $coverZ
	# Left cover patch
#	patch quadr $coverID $nfCoverZ $nfCoverY $ncoreY $coverZ $ncoreY $coreZ $coreY $coreZ $coreY $coverZ
#	# Right cover patch
#	patch quadr $coverID $nfCoverZ $nfCoverY $ncoreY $ncoreZ $ncoreY $ncoverZ $coreY $ncoverZ $coreY $ncoreZ
#	# Bottom cover patch
#	patch quadr $coverID $nfCoverZ $nfCoverY $ncoverY $coverZ $ncoverY $ncoverZ $ncoreY $ncoverZ $ncoreY $coverZ
#	# Top cover patch
#	patch quadr $coverID $nfCoverZ $nfCoverY $coverY $coverZ $coverY $ncoverZ $coverY $ncoverZ $coverY $coverZ
	
	# Define the steel layers
	# Top layer
	layer straight $steelID $numTopBars $longBarArea $coreY $ncoreZ $coreY $coreZ; 	
	# Bottom layer
	layer straight $steelID $numBotBars $longBarArea $ncoreY $ncoreZ $ncoreY $coreZ; 

	# Do intermediate layers if they exist
   	if {$numInterLayers == 0} {
		# Don't make any intermediate layers of bars
   	} else {
		# Compute spacing of intermediate layers (equally spaced)
		set interSpacing [expr (($h - 2*$cover)/[expr $numInterLayers + 1])]
		#puts "Inter spacing is $interSpacing"
		
		# Make intermediate layers
		set layerDepth [expr ($coreY - $interSpacing)]
		for {set layerNum 1} {$layerNum < [expr $numInterLayers + 1]} {incr layerNum 1} {
			layer straight $steelID $numInterBarsPerLayer $interBarArea $layerDepth $coreZ $layerDepth $ncoreZ; 
			#puts "Intermediate layer placed at $layerDepth"
			set layerDepth [expr $layerDepth - $interSpacing]
		}
   	}

	# Define the patch for the slab, if there is a slab -    
	set rightSlabZ [expr $ncoverZ - $slabWidth]
	set botSlabY [expr $coverY - $slabThick]	

	if {$slabWidth > 0 && $slabThick > 0} {
		#     					   bot/left   	   bot/right             top/right           top/left          	              
		# Careful here - need to define quadr in CCW around the patch!!!
		patch quadr $slabID $nfSlabZ $nfSlabY $botSlabY $ncoverZ $botSlabY $rightSlabZ $coverY $rightSlabZ $coverY $ncoverZ  
		#puts "Slab patch defined!"
		#puts "Slab ID is: $slabID"
	}

 	# Define steel layers for the slab
     		# Compute top and bottom slab layer heights
     		set topSlabBarY [expr $coverY - $slabBarCover]
     		set botSlabBarY [expr $botSlabY + $slabBarCover]

		# Compute number of bars to put in layers in slab - this should round to an integer result
     		set numSlabBarsInLayer [expr int($slabWidth/$slabBarSpacing)]

     		# Place layers, if there are bars to place - top then bottom
		if {$numSlabBarsInLayer > 0} {
     			layer straight $steelID $numSlabBarsInLayer $slabBarArea $topSlabBarY $ncoverZ $topSlabBarY $rightSlabZ
     			layer straight $steelID $numSlabBarsInLayer $slabBarArea $botSlabBarY $ncoverZ $botSlabBarY $rightSlabZ
			#puts "Slab layers defined with $numSlabBarsInLayer bars per layer!"
		}
   }
}
####################################################################################################
